# -*- coding: utf-8 -*-
"""Python_DataScience_Funcoes_Pacotes_Pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Eao1FGLIfUQ-A8K4lQ-6u5XXua8jUTnP
"""

!python -V

"""# Trabalhando com dados

https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.set_option.html
"""

import pandas as pd
pd.set_option('display.max_rows', 1000)   #Colocar o número máximo de linhas, importar da database, dataset

dataset = pd.read_csv('/content/db.csv', sep = ';')

dataset

dataset.dtypes

dataset[['Quilometragem', 'Valor']].describe()

dataset.info()

"""# <font color=green> 2. TRABALHANDO COM TUPLAS
---

# Criando tuplas

Tuplas são sequências imutáveis que são utilizadas para armazenar coleções de itens, geralmente heterogêneos. Podem ser construídas de várias formas:
```
- Utilizando um par de parênteses: ( )
- Utilizando uma vírgula à direita: x,
- Utilizando um par de parênteses com itens separados por vírgulas: ( x, y, z )
- Utilizando: tuple() ou tuple(iterador)
```
"""

()

1,2,3

nome = 'Passat'
valor = 153000
(nome, valor)

nomes_carros = tuple(['Jetta Variant', 'Passat', 'Crossfox', 'DS5'])
nomes_carros

type(nomes_carros)

"""# Seleções em tuplas"""

nomes_carros = tuple(['Jetta Variant', 'Passat', 'Crossfox', 'DS5'])
nomes_carros

nomes_carros[0]

nomes_carros[1]

nomes_carros[-1]

nomes_carros[1:3]

nomes_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5', ('Fusca', 'Gol', 'C4'))
nomes_carros

nomes_carros[-1]

nomes_carros[-1][1]

"""# Iterando em tuplas"""

nomes_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5')
nomes_carros

for item in nomes_carros:
  print(item)

"""### Desempacotamento de tuplas"""

nomes_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5')
nomes_carros

carro_1, carro_2, carro_3, carro_4 = nomes_carros

carro_1

carro_2

carro_3

carro_4

_, A, _, B = nomes_carros #Utilizando o underscore _ to ignorando o primeiro e o segundo item

A

B

_, C, *_ = nomes_carros #Esse *_ ignora todos pra frente

C

"""## *zip()*

https://docs.python.org/3.6/library/functions.html#zip
"""

carros = ['Jetta Variant', 'Passat', 'Crossfox', 'DS5']
carros

valores = [88078.64, 106161.94, 72832.16, 124549.07]
valores

zip(carros, valores)

list(zip(carros, valores))

for item in zip(carros, valores):
  print(item)

for carro, valor in zip(carros, valores):
  print(carro,valor)

for carro, valor in zip(carros, valores):
  if (valor > 100000):
    print(carro)

"""# <font color=green> 3. TRABALHANDO COM DICIONÁRIOS
---

# 3.1 Criando dicionários

Listas são coleções sequenciais, isto é, os itens destas sequências estão ordenados e utilizam índices (números inteiros) para acessar os valores.

Os dicionários são coleções um pouco diferentes. São estruturas de dados que representam um tipo de mapeamento. Mapeamentos são coleções de associações entre pares de valores onde o primeiro elemento do par é conhecido como chave (*key*) e o segundo como valor (*value*).

```
dicionario = {key_1: value_1, key_2: value_2, ..., key_n: value_n}
```

https://docs.python.org/3.6/library/stdtypes.html#typesmapping
"""

carros = ['Jetta Variant', 'Passat', 'Crossfox']
carros

valores = [88078.64, 106161.94, 72832.16]
valores

carros.index('Passat')

valores[carros.index('Passat')]

"""Estrutura que já faz o mapeamento do carro e o valor - Dicionário"""

dados = {'Jetta Variant': 88078.64, 'Passat': 106161.94, 'Crossfox': 72832.16}
dados

type(dados)

"""### Criando dicionários com *zip()*"""

list(zip(carros, valores))

dados = dict(zip(carros, valores))
dados

"""#  Operações com dicionários"""

dados = {'Jetta Variant': 88078.64, 'Passat': 106161.94, 'Crossfox': 72832.16}
dados

"""## *dict[ key ]*

Retorna o valor correspondente à chave (*key*) no dicionário.
"""

dados['Passat']

"""## *key in dict*

Retorna **True** se a chave (*key*) for encontrada no dicionário.
"""

'Passat' in dados

'Fusca' in dados

'Fusca' not in dados

"""## *len(dict)*

Retorna o número de itens do dicionário.
"""

len(dados) #Ele tem 3 pares;chaves;valor

"""## *dict[ key ] = value*

Inclui um item ao dicionário.
"""

dados['DS5'] = 124549.07

dados

"""## *del dict[ key ]*

Remove o item de chave (*key*) do dicionário.
"""

dados

del dados['Passat']
dados

"""#  Métodos de dicionários

https://docs.python.org/3.6/tutorial/datastructures.html#dictionaries

https://docs.python.org/3.6/library/stdtypes.html#typesmapping

## *dict.update()*

Atualiza o dicionário. Faz inclusões e atualizações
"""

dados

dados.update({'Passat': 106161.94})

dados

dados.update({'Passat': 106161.95, 'Fusca': 150000})
dados

"""## *dict.copy()*

Cria uma cópia do dicionário.
"""

dadosCopy = dados.copy()

dadosCopy

del dadosCopy['Fusca']
dadosCopy

dados

"""## *dict.pop(key[, default ])*

Se a chave for encontrada no dicionário, o item é removido e seu valor é retornado. Caso contrário, o valor especificado como *default* é retornado. Se o valor *default* não for fornecido e a chave não for encontrada no dicionário um erro será gerado.
"""

dadosCopy

dadosCopy.pop('Passat')   #Retorna quem ele eliminou

dadosCopy

#dadosCopy.pop('Passat') Ele não vai encontrar o passat porque a gente eliminou, resolve isso usando o default abaixo

"""O método copy() pode receber um parâmetro "default" que permite uma espécie de tratamento desse erro. Ou seja, se a chave não for encontrada no dicionário, nosso retorno será o valor passado como default. Em nosso exemplo, além de "Passat", passaremos a mensagem "Chave não encontrada"."""

dadosCopy.pop('Passat', 'Chave não encontrada')

dadosCopy.pop('DS5', 'Chave não encontrada')

dadosCopy

"""## *dict.clear()*

Remove todos os itens do dicionário.
"""

dadosCopy.clear()

dadosCopy

"""#  Iterando em dicionários"""

dados = {'Crossfox': 72832.16, 'DS5': 124549.07,  'Fusca': 150000,  'Jetta Variant': 88078.64,  'Passat': 106161.95}
dados

"""## *dict.keys()*

Retorna uma lista contendo as chaves (*keys*) do dicionário.
"""

dados.keys()

for key in dados.keys():
  print(dados[key])

"""## *dict.values()*

Retorna uma lista com todos os valores (*values*) do dicionário.

"""

dados.values()

"""## *dict.items()*

Retorna uma lista contendo uma tupla para cada par chave-valor (*key-value*) do dicionário.
"""

dados.items() #FEZ TUPLAS COM CHAVES VALOR

for item in dados.items():
    print(item)

# Desempacotamento de tuplas

for key, value in dados.items():
    print(key, value)

for key, value in dados.items():
  if (value > 100000):
    print(key)

"""# <font color=green>  FUNÇÕES
---
    
Funções são unidades de código reutilizáveis que realizam uma tarefa específica, podem receber alguma entrada e também podem retornar alguma resultado.

#  Built-in function

A linguagem Python possui várias funções integradas que estão sempre acessíveis. Algumas já utilizamos em nosso treinamento: type(), print(), zip(), len(), set() etc.

https://docs.python.org/3.6/library/functions.html
"""

dados = {'Jetta Variant': 88078.64, 'Passat': 106161.94, 'Crossfox': 72832.16}
dados

valores = []

for valor in dados.values(): #Cria um iterador com os valores do dicionario
  valores.append(valor)
valores

soma = 0 #Primeiro criou a variavel
for valor in dados.values():
  soma+=valor
soma

list(dados.values())

sum(dados.values())

help(print)

print?

"""#  Definindo funções sem e com parâmetros

### Funções sem parâmetros

#### Formato padrão

```
def <nome>():
    <instruções>
```
"""

def media():
  valor = (1 + 2 + 3) / 3
  print(valor)

media()

"""### Funções com parâmetros

#### Formato padrão

```
def <nome>(<param_1>, <param_2>, ..., <param_n>):
    <instruções>
```
"""

def media(number_1, number_2, number_3):
  valor = (number_1 + number_2 +number_3) / 3
  print(valor)

media (1, 2, 3)

media (23, 45, 47)

def media(lista):
  valor = sum(lista) / len(lista)
  print(valor)

media ([1, 2, 3, 4, 5, 6, 7, 8, 9])

"""# Definindo funções que retornam valores

### Funções que retornam um valor

#### Formato padrão

```
def <nome>(<param_1>, <param_2>, ..., <param_n>):
    <instruções>
    return <resultado>
```
"""

def media(lista):
  valor = sum(lista) / len(lista)
  return valor

media([1, 2, 3, 4, 5, 6, 7, 8])

resultado = media([1, 2, 3, 4, 5, 6, 7, 8])

resultado

"""### Funções que retornam mais de um valor

#### Formato padrão

```
def <nome>(<param_1>, <param_2>, ..., <param_n>):
    <instruções>
    return (<resultado_1>, <resultado_2>, ..., <resultado_n>)
```
"""

def media(lista):
  valor = sum(lista) / len(lista)
  return (valor, len(lista))

resultado = media([1, 2, 3, 4, 5, 6, 7, 8])
resultado

resultado, n = media([1, 2, 3, 4, 5, 6, 7, 8, 9])

resultado

n #Tamanho da lista

"""# <font color=green>  PANDAS BÁSICO
---

**versão: 0.25.2**
  
Pandas é uma ferramenta de manipulação de dados de alto nível, construída com base no pacote Numpy. O pacote pandas possui estruturas de dados bastante interessantes para manipulação de dados e por isso é muito utilizado por cientistas de dados.


## Estruturas de Dados

### Series

Series são arrays unidimensionais rotulados capazes de armazenar qualquer tipo de dado. Os rótulos das linhas são chamados de **index**. A forma básica de criação de uma Series é a seguinte:


```
    s = pd.Series(dados, index = index)
```

O argumento *dados* pode ser um dicionário, uma lista, um array Numpy ou uma constante.

### DataFrames

DataFrame é uma estrutura de dados tabular bidimensional com rótulos nas linha e colunas. Como a Series, os DataFrames são capazes de armazenar qualquer tipo de dados.


```
    df = pd.DataFrame(dados, index = index, columns = columns)
```

O argumento *dados* pode ser um dicionário, uma lista, um array Numpy, uma Series e outro DataFrame.

**Documentação:** https://pandas.pydata.org/pandas-docs/version/0.25/

#  Estruturas de dados
"""

import pandas as pd

"""### Criando uma Series a partir de uma lista"""

carros = ['Jetta Variant', 'Passat', 'Crossfox']
carros

pd.Series(carros)

"""### Criando um DataFrame a partir de uma lista de dicionários"""

dados = [
    {'Nome': 'Jetta Variant', 'Motor': 'Motor 4.0 Turbo', 'Ano': 2003, 'Quilometragem': 44410.0, 'Zero_km': False, 'Valor': 88078.64},
    {'Nome': 'Passat', 'Motor': 'Motor Diesel', 'Ano': 1991, 'Quilometragem': 5712.0, 'Zero_km': False, 'Valor': 106161.94},
    {'Nome': 'Crossfox', 'Motor': 'Motor Diesel V8', 'Ano': 1990, 'Quilometragem': 37123.0, 'Zero_km': False, 'Valor': 72832.16}
]

dataset = pd.DataFrame(dados)

dataset

# Modificar ordem das colunas
dataset[['Nome', 'Motor', 'Ano', 'Quilometragem', 'Zero_km', 'Valor']]

"""### Criando um DataFrame a partir de um dicionário"""

dados = {
    'Nome': ['Jetta Variant', 'Passat', 'Crossfox'], 
    'Motor': ['Motor 4.0 Turbo', 'Motor Diesel', 'Motor Diesel V8'],
    'Ano': [2003, 1991, 1990],
    'Quilometragem': [44410.0, 5712.0, 37123.0],
    'Zero_km': [False, False, False],
    'Valor': [88078.64, 106161.94, 72832.16]
}

dataset = pd.DataFrame(dados)

dataset

"""### Criando um DataFrame a partir de um arquivo externo"""

dataset = pd.read_csv('/content/db.csv', sep = ';', index_col = 0)

dataset

"""# Seleções com DataFrames"""

dataset.head()

"""### Selecionando colunas"""

dataset['Valor']

type(dataset['Valor'])

dataset[['Valor']]

type(dataset[['Valor']])

"""### Selecionando linhas - [ i : j ] 

<font color=red>**Observação:**</font> A indexação tem origem no zero e nos fatiamentos (*slices*) a linha com índice i é **incluída** e a linha com índice j **não é incluída** no resultado.
"""

dataset[0:3]

"""### Utilizando .loc para seleções

<font color=red>**Observação:**</font> Seleciona um grupo de linhas e colunas segundo os rótulos ou uma matriz booleana.
"""

dataset.loc['Passat']

dataset.loc[['Passat', 'DS5']]

dataset.loc[['Passat', 'DS5'], ['Motor', 'Valor']]

dataset.loc[:, ['Motor', 'Valor']]

"""### Utilizando .iloc para seleções

<font color=red>**Observação:**</font> Seleciona com base nos índices, ou seja, se baseia na posição das informações.
"""

dataset.head()

dataset.iloc[[1]]

dataset.iloc[1:4]

dataset.iloc[1:4, [0, 5, 2]]

dataset.iloc[[1, 42, 22], [0, 5, 2]]

dataset.iloc[:, [0, 5, 2]]

"""# Queries com DataFrames
Aquilo que chamamos de queries são, basicamente, consultas que podem ser realizadas em dataframes, de modo semelhante às seleções, mas utilizando técnicas mais sofisticadas.
"""

dataset.head()

dataset.Motor

select = dataset.Motor == 'Motor Diesel'

type(select)

dataset[select]

dataset[(dataset.Motor == 'Motor Diesel') & (dataset.Zero_km == True)]   #& significa a condição E

(dataset.Motor == 'Motor Diesel') & (dataset.Zero_km == True)

"""### Utilizando o método query"""

dataset.query('Motor == "Motor Diesel" and Zero_km == True')

"""# Iterando com DataFrames"""

dataset.head()

for item in dataset:
    print(item)

list(dataset.iterrows())

for index, row in dataset.iterrows():
  if(2019 - row['Ano'] != 0):
    dataset.loc[index, 'Km_media'] = row['Quilometragem'] / (2019 - row['Ano']) 
  else:
    dataset.loc[index, 'Km_media'] = 0

dataset

"""# Tratamento de dados"""

dataset.head()

dataset.info()

dataset.Quilometragem.isna()

dataset[dataset.Quilometragem.isna()]

dataset.fillna(0)   #No valor do Na ele fica com 0

dataset.fillna(0, inplace = True) #Esse inplace faz ele já salvar automaticamente

dataset.query('Zero_km == True')

dataset = pd.read_csv('/content/db.csv', sep = ';')

dataset

dataset.dropna(subset = ['Quilometragem'], inplace = True)

dataset

